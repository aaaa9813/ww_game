// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server_msg.proto

#ifndef PROTOBUF_server_5fmsg_2eproto__INCLUDED
#define PROTOBUF_server_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_server_5fmsg_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsServerMsgImpl();
void InitDefaultsServerMsg();
void InitDefaultsCommandImpl();
void InitDefaultsCommand();
void InitDefaultsRequestImpl();
void InitDefaultsRequest();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsIndicationImpl();
void InitDefaultsIndication();
void InitDefaultsEnterGameRequestImpl();
void InitDefaultsEnterGameRequest();
inline void InitDefaults() {
  InitDefaultsServerMsg();
  InitDefaultsCommand();
  InitDefaultsRequest();
  InitDefaultsResponse();
  InitDefaultsIndication();
  InitDefaultsEnterGameRequest();
}
}  // namespace protobuf_server_5fmsg_2eproto
namespace ww {
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class EnterGameRequest;
class EnterGameRequestDefaultTypeInternal;
extern EnterGameRequestDefaultTypeInternal _EnterGameRequest_default_instance_;
class Indication;
class IndicationDefaultTypeInternal;
extern IndicationDefaultTypeInternal _Indication_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ServerMsg;
class ServerMsgDefaultTypeInternal;
extern ServerMsgDefaultTypeInternal _ServerMsg_default_instance_;
}  // namespace ww
namespace ww {

enum MSG_TYPE {
  MSG_ENTER_GAME = 0,
  MSG_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MSG_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MSG_TYPE_IsValid(int value);
const MSG_TYPE MSG_TYPE_MIN = MSG_ENTER_GAME;
const MSG_TYPE MSG_TYPE_MAX = MSG_ENTER_GAME;
const int MSG_TYPE_ARRAYSIZE = MSG_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MSG_TYPE_descriptor();
inline const ::std::string& MSG_TYPE_Name(MSG_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MSG_TYPE_descriptor(), value);
}
inline bool MSG_TYPE_Parse(
    const ::std::string& name, MSG_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MSG_TYPE>(
    MSG_TYPE_descriptor(), name, value);
}
// ===================================================================

class ServerMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ww.ServerMsg) */ {
 public:
  ServerMsg();
  virtual ~ServerMsg();

  ServerMsg(const ServerMsg& from);

  inline ServerMsg& operator=(const ServerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMsg(ServerMsg&& from) noexcept
    : ServerMsg() {
    *this = ::std::move(from);
  }

  inline ServerMsg& operator=(ServerMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMsg* internal_default_instance() {
    return reinterpret_cast<const ServerMsg*>(
               &_ServerMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ServerMsg* other);
  friend void swap(ServerMsg& a, ServerMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServerMsg& from);
  void MergeFrom(const ServerMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServerMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ww.Request msg_req = 2;
  bool has_msg_req() const;
  void clear_msg_req();
  static const int kMsgReqFieldNumber = 2;
  const ::ww::Request& msg_req() const;
  ::ww::Request* release_msg_req();
  ::ww::Request* mutable_msg_req();
  void set_allocated_msg_req(::ww::Request* msg_req);

  // .ww.Response msg_rep = 3;
  bool has_msg_rep() const;
  void clear_msg_rep();
  static const int kMsgRepFieldNumber = 3;
  const ::ww::Response& msg_rep() const;
  ::ww::Response* release_msg_rep();
  ::ww::Response* mutable_msg_rep();
  void set_allocated_msg_rep(::ww::Response* msg_rep);

  // .ww.Command msg_comm = 4;
  bool has_msg_comm() const;
  void clear_msg_comm();
  static const int kMsgCommFieldNumber = 4;
  const ::ww::Command& msg_comm() const;
  ::ww::Command* release_msg_comm();
  ::ww::Command* mutable_msg_comm();
  void set_allocated_msg_comm(::ww::Command* msg_comm);

  // .ww.Indication msg_ind = 5;
  bool has_msg_ind() const;
  void clear_msg_ind();
  static const int kMsgIndFieldNumber = 5;
  const ::ww::Indication& msg_ind() const;
  ::ww::Indication* release_msg_ind();
  ::ww::Indication* mutable_msg_ind();
  void set_allocated_msg_ind(::ww::Indication* msg_ind);

  // .ww.MSG_TYPE msg_type = 1;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  ::ww::MSG_TYPE msg_type() const;
  void set_msg_type(::ww::MSG_TYPE value);

  // @@protoc_insertion_point(class_scope:ww.ServerMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ww::Request* msg_req_;
  ::ww::Response* msg_rep_;
  ::ww::Command* msg_comm_;
  ::ww::Indication* msg_ind_;
  int msg_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_server_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_server_5fmsg_2eproto::InitDefaultsServerMsgImpl();
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ww.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const PROTOBUF_FINAL { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ww.Command)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_server_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_server_5fmsg_2eproto::InitDefaultsCommandImpl();
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ww.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ww.EnterGameRequest entergamereq = 1;
  bool has_entergamereq() const;
  void clear_entergamereq();
  static const int kEntergamereqFieldNumber = 1;
  const ::ww::EnterGameRequest& entergamereq() const;
  ::ww::EnterGameRequest* release_entergamereq();
  ::ww::EnterGameRequest* mutable_entergamereq();
  void set_allocated_entergamereq(::ww::EnterGameRequest* entergamereq);

  // @@protoc_insertion_point(class_scope:ww.Request)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ww::EnterGameRequest* entergamereq_;
  mutable int _cached_size_;
  friend struct ::protobuf_server_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_server_5fmsg_2eproto::InitDefaultsRequestImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ww.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ww.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_server_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_server_5fmsg_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class Indication : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ww.Indication) */ {
 public:
  Indication();
  virtual ~Indication();

  Indication(const Indication& from);

  inline Indication& operator=(const Indication& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Indication(Indication&& from) noexcept
    : Indication() {
    *this = ::std::move(from);
  }

  inline Indication& operator=(Indication&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Indication& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Indication* internal_default_instance() {
    return reinterpret_cast<const Indication*>(
               &_Indication_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Indication* other);
  friend void swap(Indication& a, Indication& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Indication* New() const PROTOBUF_FINAL { return New(NULL); }

  Indication* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Indication& from);
  void MergeFrom(const Indication& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Indication* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ww.Indication)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_server_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_server_5fmsg_2eproto::InitDefaultsIndicationImpl();
};
// -------------------------------------------------------------------

class EnterGameRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ww.EnterGameRequest) */ {
 public:
  EnterGameRequest();
  virtual ~EnterGameRequest();

  EnterGameRequest(const EnterGameRequest& from);

  inline EnterGameRequest& operator=(const EnterGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnterGameRequest(EnterGameRequest&& from) noexcept
    : EnterGameRequest() {
    *this = ::std::move(from);
  }

  inline EnterGameRequest& operator=(EnterGameRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterGameRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterGameRequest* internal_default_instance() {
    return reinterpret_cast<const EnterGameRequest*>(
               &_EnterGameRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(EnterGameRequest* other);
  friend void swap(EnterGameRequest& a, EnterGameRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnterGameRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterGameRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterGameRequest& from);
  void MergeFrom(const EnterGameRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterGameRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 uidlist = 2;
  int uidlist_size() const;
  void clear_uidlist();
  static const int kUidlistFieldNumber = 2;
  ::google::protobuf::uint32 uidlist(int index) const;
  void set_uidlist(int index, ::google::protobuf::uint32 value);
  void add_uidlist(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      uidlist() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_uidlist();

  // uint32 gameid = 1;
  void clear_gameid();
  static const int kGameidFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ww.EnterGameRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > uidlist_;
  mutable int _uidlist_cached_byte_size_;
  ::google::protobuf::uint32 gameid_;
  mutable int _cached_size_;
  friend struct ::protobuf_server_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_server_5fmsg_2eproto::InitDefaultsEnterGameRequestImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerMsg

// .ww.MSG_TYPE msg_type = 1;
inline void ServerMsg::clear_msg_type() {
  msg_type_ = 0;
}
inline ::ww::MSG_TYPE ServerMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:ww.ServerMsg.msg_type)
  return static_cast< ::ww::MSG_TYPE >(msg_type_);
}
inline void ServerMsg::set_msg_type(::ww::MSG_TYPE value) {
  
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:ww.ServerMsg.msg_type)
}

// .ww.Request msg_req = 2;
inline bool ServerMsg::has_msg_req() const {
  return this != internal_default_instance() && msg_req_ != NULL;
}
inline void ServerMsg::clear_msg_req() {
  if (GetArenaNoVirtual() == NULL && msg_req_ != NULL) {
    delete msg_req_;
  }
  msg_req_ = NULL;
}
inline const ::ww::Request& ServerMsg::msg_req() const {
  const ::ww::Request* p = msg_req_;
  // @@protoc_insertion_point(field_get:ww.ServerMsg.msg_req)
  return p != NULL ? *p : *reinterpret_cast<const ::ww::Request*>(
      &::ww::_Request_default_instance_);
}
inline ::ww::Request* ServerMsg::release_msg_req() {
  // @@protoc_insertion_point(field_release:ww.ServerMsg.msg_req)
  
  ::ww::Request* temp = msg_req_;
  msg_req_ = NULL;
  return temp;
}
inline ::ww::Request* ServerMsg::mutable_msg_req() {
  
  if (msg_req_ == NULL) {
    msg_req_ = new ::ww::Request;
  }
  // @@protoc_insertion_point(field_mutable:ww.ServerMsg.msg_req)
  return msg_req_;
}
inline void ServerMsg::set_allocated_msg_req(::ww::Request* msg_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_req_;
  }
  if (msg_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg_req, submessage_arena);
    }
    
  } else {
    
  }
  msg_req_ = msg_req;
  // @@protoc_insertion_point(field_set_allocated:ww.ServerMsg.msg_req)
}

// .ww.Response msg_rep = 3;
inline bool ServerMsg::has_msg_rep() const {
  return this != internal_default_instance() && msg_rep_ != NULL;
}
inline void ServerMsg::clear_msg_rep() {
  if (GetArenaNoVirtual() == NULL && msg_rep_ != NULL) {
    delete msg_rep_;
  }
  msg_rep_ = NULL;
}
inline const ::ww::Response& ServerMsg::msg_rep() const {
  const ::ww::Response* p = msg_rep_;
  // @@protoc_insertion_point(field_get:ww.ServerMsg.msg_rep)
  return p != NULL ? *p : *reinterpret_cast<const ::ww::Response*>(
      &::ww::_Response_default_instance_);
}
inline ::ww::Response* ServerMsg::release_msg_rep() {
  // @@protoc_insertion_point(field_release:ww.ServerMsg.msg_rep)
  
  ::ww::Response* temp = msg_rep_;
  msg_rep_ = NULL;
  return temp;
}
inline ::ww::Response* ServerMsg::mutable_msg_rep() {
  
  if (msg_rep_ == NULL) {
    msg_rep_ = new ::ww::Response;
  }
  // @@protoc_insertion_point(field_mutable:ww.ServerMsg.msg_rep)
  return msg_rep_;
}
inline void ServerMsg::set_allocated_msg_rep(::ww::Response* msg_rep) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_rep_;
  }
  if (msg_rep) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg_rep = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg_rep, submessage_arena);
    }
    
  } else {
    
  }
  msg_rep_ = msg_rep;
  // @@protoc_insertion_point(field_set_allocated:ww.ServerMsg.msg_rep)
}

// .ww.Command msg_comm = 4;
inline bool ServerMsg::has_msg_comm() const {
  return this != internal_default_instance() && msg_comm_ != NULL;
}
inline void ServerMsg::clear_msg_comm() {
  if (GetArenaNoVirtual() == NULL && msg_comm_ != NULL) {
    delete msg_comm_;
  }
  msg_comm_ = NULL;
}
inline const ::ww::Command& ServerMsg::msg_comm() const {
  const ::ww::Command* p = msg_comm_;
  // @@protoc_insertion_point(field_get:ww.ServerMsg.msg_comm)
  return p != NULL ? *p : *reinterpret_cast<const ::ww::Command*>(
      &::ww::_Command_default_instance_);
}
inline ::ww::Command* ServerMsg::release_msg_comm() {
  // @@protoc_insertion_point(field_release:ww.ServerMsg.msg_comm)
  
  ::ww::Command* temp = msg_comm_;
  msg_comm_ = NULL;
  return temp;
}
inline ::ww::Command* ServerMsg::mutable_msg_comm() {
  
  if (msg_comm_ == NULL) {
    msg_comm_ = new ::ww::Command;
  }
  // @@protoc_insertion_point(field_mutable:ww.ServerMsg.msg_comm)
  return msg_comm_;
}
inline void ServerMsg::set_allocated_msg_comm(::ww::Command* msg_comm) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_comm_;
  }
  if (msg_comm) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg_comm = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg_comm, submessage_arena);
    }
    
  } else {
    
  }
  msg_comm_ = msg_comm;
  // @@protoc_insertion_point(field_set_allocated:ww.ServerMsg.msg_comm)
}

// .ww.Indication msg_ind = 5;
inline bool ServerMsg::has_msg_ind() const {
  return this != internal_default_instance() && msg_ind_ != NULL;
}
inline void ServerMsg::clear_msg_ind() {
  if (GetArenaNoVirtual() == NULL && msg_ind_ != NULL) {
    delete msg_ind_;
  }
  msg_ind_ = NULL;
}
inline const ::ww::Indication& ServerMsg::msg_ind() const {
  const ::ww::Indication* p = msg_ind_;
  // @@protoc_insertion_point(field_get:ww.ServerMsg.msg_ind)
  return p != NULL ? *p : *reinterpret_cast<const ::ww::Indication*>(
      &::ww::_Indication_default_instance_);
}
inline ::ww::Indication* ServerMsg::release_msg_ind() {
  // @@protoc_insertion_point(field_release:ww.ServerMsg.msg_ind)
  
  ::ww::Indication* temp = msg_ind_;
  msg_ind_ = NULL;
  return temp;
}
inline ::ww::Indication* ServerMsg::mutable_msg_ind() {
  
  if (msg_ind_ == NULL) {
    msg_ind_ = new ::ww::Indication;
  }
  // @@protoc_insertion_point(field_mutable:ww.ServerMsg.msg_ind)
  return msg_ind_;
}
inline void ServerMsg::set_allocated_msg_ind(::ww::Indication* msg_ind) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_ind_;
  }
  if (msg_ind) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg_ind = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg_ind, submessage_arena);
    }
    
  } else {
    
  }
  msg_ind_ = msg_ind;
  // @@protoc_insertion_point(field_set_allocated:ww.ServerMsg.msg_ind)
}

// -------------------------------------------------------------------

// Command

// -------------------------------------------------------------------

// Request

// .ww.EnterGameRequest entergamereq = 1;
inline bool Request::has_entergamereq() const {
  return this != internal_default_instance() && entergamereq_ != NULL;
}
inline void Request::clear_entergamereq() {
  if (GetArenaNoVirtual() == NULL && entergamereq_ != NULL) {
    delete entergamereq_;
  }
  entergamereq_ = NULL;
}
inline const ::ww::EnterGameRequest& Request::entergamereq() const {
  const ::ww::EnterGameRequest* p = entergamereq_;
  // @@protoc_insertion_point(field_get:ww.Request.entergamereq)
  return p != NULL ? *p : *reinterpret_cast<const ::ww::EnterGameRequest*>(
      &::ww::_EnterGameRequest_default_instance_);
}
inline ::ww::EnterGameRequest* Request::release_entergamereq() {
  // @@protoc_insertion_point(field_release:ww.Request.entergamereq)
  
  ::ww::EnterGameRequest* temp = entergamereq_;
  entergamereq_ = NULL;
  return temp;
}
inline ::ww::EnterGameRequest* Request::mutable_entergamereq() {
  
  if (entergamereq_ == NULL) {
    entergamereq_ = new ::ww::EnterGameRequest;
  }
  // @@protoc_insertion_point(field_mutable:ww.Request.entergamereq)
  return entergamereq_;
}
inline void Request::set_allocated_entergamereq(::ww::EnterGameRequest* entergamereq) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete entergamereq_;
  }
  if (entergamereq) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      entergamereq = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entergamereq, submessage_arena);
    }
    
  } else {
    
  }
  entergamereq_ = entergamereq;
  // @@protoc_insertion_point(field_set_allocated:ww.Request.entergamereq)
}

// -------------------------------------------------------------------

// Response

// -------------------------------------------------------------------

// Indication

// -------------------------------------------------------------------

// EnterGameRequest

// uint32 gameid = 1;
inline void EnterGameRequest::clear_gameid() {
  gameid_ = 0u;
}
inline ::google::protobuf::uint32 EnterGameRequest::gameid() const {
  // @@protoc_insertion_point(field_get:ww.EnterGameRequest.gameid)
  return gameid_;
}
inline void EnterGameRequest::set_gameid(::google::protobuf::uint32 value) {
  
  gameid_ = value;
  // @@protoc_insertion_point(field_set:ww.EnterGameRequest.gameid)
}

// repeated uint32 uidlist = 2;
inline int EnterGameRequest::uidlist_size() const {
  return uidlist_.size();
}
inline void EnterGameRequest::clear_uidlist() {
  uidlist_.Clear();
}
inline ::google::protobuf::uint32 EnterGameRequest::uidlist(int index) const {
  // @@protoc_insertion_point(field_get:ww.EnterGameRequest.uidlist)
  return uidlist_.Get(index);
}
inline void EnterGameRequest::set_uidlist(int index, ::google::protobuf::uint32 value) {
  uidlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:ww.EnterGameRequest.uidlist)
}
inline void EnterGameRequest::add_uidlist(::google::protobuf::uint32 value) {
  uidlist_.Add(value);
  // @@protoc_insertion_point(field_add:ww.EnterGameRequest.uidlist)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EnterGameRequest::uidlist() const {
  // @@protoc_insertion_point(field_list:ww.EnterGameRequest.uidlist)
  return uidlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EnterGameRequest::mutable_uidlist() {
  // @@protoc_insertion_point(field_mutable_list:ww.EnterGameRequest.uidlist)
  return &uidlist_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ww

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ww::MSG_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ww::MSG_TYPE>() {
  return ::ww::MSG_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_server_5fmsg_2eproto__INCLUDED
